'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

module.exports = {
  rules: {
    'require-sort': {
      meta: {
        type: 'suggestion',
        docs: {
          description: 'enforce sorted require declarations within modules',
          category: 'ECMAScript 6',
          recommended: false,
          url: 'https://github.com/zcuric/eslint-plugin-require-sort'
        },
        schema: [{
          type: 'object',
          properties: {
            ignoreCase: {
              type: 'boolean',
              default: false
            },
            propertySyntaxSortOrder: {
              type: 'array',
              items: {
                enum: ['none', 'multiple', 'single']
              },
              uniqueItems: true,
              minItems: 3,
              maxItems: 3
            },
            ignoreDeclarationSort: {
              type: 'boolean',
              default: false
            },
            ignorePropertySort: {
              type: 'boolean',
              default: false
            }
          },
          additionalProperties: false
        }],
        fixable: 'code'
      },
      create: function create(context) {
        var configuration = context.options[0] || {};
        var _configuration$ignore = configuration.ignoreCase,
            ignoreCase = _configuration$ignore === void 0 ? false : _configuration$ignore,
            _configuration$ignore2 = configuration.ignoreDeclarationSort,
            ignoreDeclarationSort = _configuration$ignore2 === void 0 ? false : _configuration$ignore2,
            _configuration$ignore3 = configuration.ignorePropertySort,
            ignorePropertySort = _configuration$ignore3 === void 0 ? false : _configuration$ignore3,
            _configuration$proper = configuration.propertySyntaxSortOrder,
            propertySyntaxSortOrder = _configuration$proper === void 0 ? ['none', 'multiple', 'single'] : _configuration$proper;
        var sourceCode = context.getSourceCode();
        var nodes = [];
        var previousNode = null;

        var handleDeclarationSort = function handleDeclarationSort(node) {
          if (previousNode) {
            var currentIndex = getPropertySyntaxIndex(node);
            var previousIndex = getPropertySyntaxIndex(previousNode);
            /*
             * When the current declaration uses a different property syntax,
             * then check if the ordering is correct.
             * Otherwise, make a default string compare (like rule sort-vars to be consistent)
             * of the first used property name.
             */

            if (currentIndex === previousIndex) {
              reportOnAlphabeticalSort(node, previousNode);
            }

            if (currentIndex < previousIndex) {
              reportOnExpectedSyntax(node, currentIndex, previousIndex);
            }
          }

          previousNode = node;
        };

        var handlePropertySort = function handlePropertySort(node) {
          if (isStaticRequire(node)) return;
          if (!node.declarations[0].id.properties) return;
          var properties = node.declarations[0].id.properties;

          var mergeText = function mergeText(sourceText, property, index) {
            var textAfterProperty = '';

            if (index !== properties.length - 1) {
              textAfterProperty = sourceCode.getText().slice(properties[index].range[1], properties[index + 1].range[0]);
            }

            return sourceText + sourceCode.getText(property) + textAfterProperty;
          };

          var firstUnsortedIndex = properties.map(getSortableName).findIndex(function (name, index, array) {
            return array[index - 1] > name;
          });

          var fix = function fix(_ref) {
            var replaceTextRange = _ref.replaceTextRange;
            // If there are comments in the property list, don't rearrange the properties.
            if (hasComments(properties)) return null;
            var range = [properties[0].range[0], properties[properties.length - 1].range[1]];

            var text = _toConsumableArray(properties).sort(sortByName).reduce(mergeText, '');

            return replaceTextRange(range, text);
          };

          if (firstUnsortedIndex === -1) return;
          var value = properties[firstUnsortedIndex].value;
          var propertyName = isAssignmentPattern(value) ? value.left.name : value.name;
          context.report({
            node: properties[firstUnsortedIndex],
            message: "Property '{{propertyName}}' of the require declaration should be sorted alphabetically.",
            data: {
              propertyName: propertyName
            },
            fix: fix
          });
        };

        var isTopLevel = function isTopLevel(_ref2) {
          var parent = _ref2.parent;
          return parent.type === 'Program';
        };

        var isStaticRequire = function isStaticRequire(node) {
          var _node$callee, _node$callee2, _node$arguments;

          if (node.type !== 'CallExpression') return false;
          return ((_node$callee = node.callee) === null || _node$callee === void 0 ? void 0 : _node$callee.type) === 'Identifier' && ((_node$callee2 = node.callee) === null || _node$callee2 === void 0 ? void 0 : _node$callee2.name) === 'require' && ((_node$arguments = node.arguments) === null || _node$arguments === void 0 ? void 0 : _node$arguments.length) === 1;
        };

        var isRequire = function isRequire(node) {
          var _node$declarations$, _node$declarations$$i, _node$declarations$$i2;

          return ((_node$declarations$ = node.declarations[0]) === null || _node$declarations$ === void 0 ? void 0 : (_node$declarations$$i = _node$declarations$.init) === null || _node$declarations$$i === void 0 ? void 0 : (_node$declarations$$i2 = _node$declarations$$i.callee) === null || _node$declarations$$i2 === void 0 ? void 0 : _node$declarations$$i2.name) === 'require';
        };

        var isAssignmentPattern = function isAssignmentPattern(node) {
          return (node === null || node === void 0 ? void 0 : node.type) === 'AssignmentPattern';
        };

        var hasObjectPattern = function hasObjectPattern(node) {
          var _node$declarations$2, _node$declarations$2$;

          return ((_node$declarations$2 = node.declarations[0]) === null || _node$declarations$2 === void 0 ? void 0 : (_node$declarations$2$ = _node$declarations$2.id) === null || _node$declarations$2$ === void 0 ? void 0 : _node$declarations$2$.type) === 'ObjectPattern';
        };

        var hasMultipleProperties = function hasMultipleProperties(node) {
          var _node$declarations$3, _node$declarations$3$;

          return ((_node$declarations$3 = node.declarations[0]) === null || _node$declarations$3 === void 0 ? void 0 : (_node$declarations$3$ = _node$declarations$3.id) === null || _node$declarations$3$ === void 0 ? void 0 : _node$declarations$3$.properties.length) > 1;
        };

        var hasComments = function hasComments(properties) {
          return properties.some(function (property) {
            var commentsBefore = sourceCode.getCommentsBefore(property);
            var commentsAfter = sourceCode.getCommentsAfter(property);
            return commentsBefore.length || commentsAfter.length;
          });
        };

        var getSortableName = function getSortableName(_ref3) {
          var value = _ref3.value;
          var name = isAssignmentPattern(value) ? value.left.name : value.name;
          if (name) return ignoreCase ? name.toLowerCase() : name;
          return null;
        };

        var sortByName = function sortByName(propertyA, propertyB) {
          var aName = getSortableName(propertyA);
          var bName = getSortableName(propertyB);
          return aName > bName ? 1 : -1;
        };

        var getPropertySyntax = function getPropertySyntax(node) {
          if (isStaticRequire(node)) return 'none';

          if (!hasObjectPattern(node) || !hasMultipleProperties(node)) {
            return 'single';
          }

          return 'multiple';
        };

        var getPropertySyntaxIndex = function getPropertySyntaxIndex(node) {
          return propertySyntaxSortOrder.indexOf(getPropertySyntax(node));
        };

        var getDeclarationName = function getDeclarationName(node) {
          if (isStaticRequire(node)) return node.arguments[0].value;
          if (!hasObjectPattern(node)) return node.declarations[0].id.name;
          var value = node.declarations[0].id.properties[0].value;
          return isAssignmentPattern(value) ? value.left.name : value.name;
        };

        var reportOnAlphabeticalSort = function reportOnAlphabeticalSort(node, previousNode) {
          var firstName = getDeclarationName(node);
          var previousName = getDeclarationName(previousNode);

          if (ignoreCase) {
            previousName = previousName && previousName.toLowerCase();
            firstName = firstName && firstName.toLowerCase();
          }

          if (previousName && firstName && firstName < previousName) {
            context.report({
              node: node,
              message: 'Requires should be sorted alphabetically.'
            });
          }
        };

        var reportOnExpectedSyntax = function reportOnExpectedSyntax(node, currentIndex, previousIndex) {
          context.report({
            node: node,
            message: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.",
            data: {
              syntaxA: propertySyntaxSortOrder[currentIndex],
              syntaxB: propertySyntaxSortOrder[previousIndex]
            }
          });
        };

        return {
          ExpressionStatement: function ExpressionStatement(node) {
            if (!isTopLevel(node)) return;
            if (!isStaticRequire(node.expression)) return;
            nodes.push(node.expression);
          },
          VariableDeclaration: function VariableDeclaration(node) {
            if (!isTopLevel(node)) return;
            if (!isRequire(node)) return;
            nodes.push(node);
          },
          'Program:exit': function ProgramExit() {
            if (!ignoreDeclarationSort) nodes.forEach(handleDeclarationSort);
            if (!ignorePropertySort) nodes.forEach(handlePropertySort);
          }
        };
      }
    }
  }
};